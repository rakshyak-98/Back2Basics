- tasks are handled sequentially within the same thread because of stack based programming language.
- JavaScript is synchronous by default 
- is single threaded within the same process
- all tasks and operations and handled sequentially within that single thread
- code cannot create new threads and run in parallel
- handle work that  will result in visual changes to the user interface.
- data can change constantly.
	- it would be extremely slow if the JavaScript engine had to check each time which data type a certain value has.
	- it can happen that the same piece of code suddenly returns a different type of data. If that happens machine code gets de-optimized, and the engine falls back to interpreting the generated byte code.

- includes features that allow it to handle multi-threaded operations.
- it offer a feature called [[web worker]] that can mimic multi-threading behavior.

> [!NOTE] data sent between workers and the main thread is copied, not shared. Objects are serialized and de-serialized, which can impact performance if large amounts of data are being sent.

 > [!NOTE] Just like a `for .. in` loop, `Object.keys/values/entries` ignore symbolic properties. 
 
 ## Modules

modules are reusable blocks of code that can be imported into other files.

- used to encapsulate related code into a single unit of code that can be used in other parts of the program.
- split our code into multiple files and reuse it across multiple files.

## How does JavaScript handle errors

### `try...catch` blocks

- basic way to handle errors
- are synchronous and can only be used to handle errors in synchronous code.
- not suitable for asynchronous code, such as callback and promises.
### Techniques for handling errors in JavaScript
- returning rejected promises in asynchronous functions or using `catch` methods to handle asynchronous errors.

### callback
- callback are most common way to handle errors in asynchronous code.


### Event emitter

- event emitters more advanced way to handle errors in asynchronous code.
    - returned by functions and emit an error when they fail.
    - resolved when the function completes and rejected when it fails.

- equality operator
- converts both operands to a common type before comparing.
- strict equality operator
- without type coercion.
- compares both the value and the type of the operands.

## Event Loops
- JavaScript concurrency model.
- handle asynchronous operations and callbacks.

### Event delegation
- attaching an event listener to a parent element to listen for events that occur on its descendant elements.
- allows to handle events centrally, even for dynamically added or removed elements, instead of attaching event listeners to each individual element.

### Closures
- a function is defined within another function.
- inner function have access to the outer function lexical scope.
- even after the outer function has returned, the inner function retains access to the outer function lexical scope, as long as the inner function itself is still referenced.

### Prototype-based inheritance
- each object in JavaScript has a prototype object,
- which it inherits properties and methods from.

### Object
- create with new keyword with constructor function.
    - create instance of objects based on that constructor.
- `Object.create`
    - creates a new object with the specified prototype object.
    - allows to create an object that inherits properties from another object directly, without need of constructor function.
- object literals `{}` or ES6 `class` syntax


## Transpilers
- translates source code to another source code.
- parse modern code and rewrite it using older syntax constructs, so that it'll work in outdated engines.
- developer deploys the trans piled code to the server ([Babel](https://babeljs.io/))
- [webpack](https://webpack.js.org/) provide a means to run a transpiler automatically on every code change, so it's very easy to integrate into development process.

## Hoisting
- function declarations are moved to the top of their containing scope.
- declarations are hoisted not initialization or assignments.

## Asynchronous programming
- allows you to performs tasks without blocking the main thread.
- handling operations like fetching data from a server, reading files, or waiting for user input.
- callbacks
    - pass function to be executed once the asynchronous task is complete.
    - can lead to callback hell, making the code difficult to read and maintain.
- promises
    - cleaner and more flexible way to handle asynchronous operations.
    - promise represents a value (completion or failure).
    - support chaining, error propagation, and composing asynchronous operations.
- `await` keyword provide syntactic sugar for working with promises.
- `await` keyword pauses the execution of an async function until a promise is settled.
- this make it more like synchronous code, improving readability and maintainability.

### Promise
- promises are a more modern way to handle errors in asynchronous code.
    - returned by function and can be chained together.
    - resolved when the function completes and rejected when it fails.
#### promise API
- 6 static methods
```javascript
let promise = Promise.all(iterable);
```
- takes an iterable (usually, an array of promises) and return a new promise.
- the new promise resolves when all listed promises are resolved, and the array of their results becomes its result.
- the order of the resulting array members is the same as in its source promises. Even though the first promise takes the longest time to resolve. It will still first in the array of results.
```javascript
let urls = [
	'https://api.github.com/users/iliakan',
	'https://api/github.com/users/remy',
	'https://api/github.com/users/jeresig'
];

let requests = urls.map(url => fetch(url));

Promise.all(requests)
	.then(response => response.forEach(
		response => console.log(response.status))
	)
```

## Stream
Streams are objects that allow you to read data from a source or write data to a destination in continuous manner.
- used to handle large amounts of data efficiently.

## De-bouncing

## Throttling

## memorize